/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Data;
using System.Linq;
using System.Collections.Generic;
using OutSystems.HubEdition.Extensibility.Data;
using OutSystems.HubEdition.Extensibility.Data.DatabaseObjects;
using OutSystems.HubEdition.Extensibility.Data.IntrospectionService;
using OutSystems.RuntimeCommon;
using InterSystems.Data.CacheClient;
using InterSystems.Data.CacheTypes;

namespace OutSystems.HubEdition.DatabaseProvider.Cache.Introspection {

    /// <summary>
    /// Inspects a database server to retrieve information about its data model.
    /// </summary>
    public class CacheIntrospectionService : BaseIntrospectionService {

        // Caché ODBC Type enum
        public enum CacheOdbcType {
            GUID          = -11,
            BIT           = -7,
            TINYINT       = -6,
            BIGINT        = -5,
            LONGVARBINARY = -4,
            VARBINARY     = -3,
            BINARY        = -2,
            LONGVARCHAR   = -1,
            UNKNOWN       = 0,
            CHAR          = 1,
            NUMERIC       = 2,
            DECIMAL       = 3,
            INTEGER       = 4,
            SMALLINT      = 5,
            FLOAT         = 6,
            REAL          = 7,
            DOUBLE        = 8,
            DATE          = 9,
            TIME          = 10,
            TIMESTAMP     = 11,
            VARCHAR       = 12
        };


        protected delegate CacheDataTypeInfo CreateDataTypeInfo(int odbcType, string cacheDataType, int length, int precision, int scale, int datetimePrecision);

        protected delegate CacheTableSourceColumnInfo CreateColumnInfo(ITableSourceInfo tableSource, string columnName,
            IDataTypeInfo dataType, bool isMandatory, bool isPrimaryKey, bool isAutoGenerated);

        /// <summary>
        /// Initializes a new instance of the <see cref="CacheIntrospectionService"/> class.
        /// </summary>
        /// <param name="databaseServices">The database services.</param>
        public CacheIntrospectionService(IDatabaseServices databaseServices) : base(databaseServices) {}

        /// <summary>
        /// Returns the list of databases that can be accessed from the current configuration. A database is a logical group of data objects (e.g. tables, views)
        /// that the plugin maps to a db-specific concept (e.g. SQL Server catalog or Oracle schema).
        /// </summary>
        /// <returns>List of available databases in the given server</returns>
        /// <exception cref="System.Data.Common.DbException">if an error occurs while accessing the database</exception>
        public override IEnumerable<IDatabaseInfo> ListDatabases() {

            List<IDatabaseInfo> result = new List<IDatabaseInfo>();

            using (IDbConnection conn = DatabaseServices.TransactionService.CreateConnection()) {
                IDbCommand cmd = DatabaseServices.ExecutionService.CreateCommand(conn, 
                    "SELECT DISTINCT SqlSchemaName from %dictionary.compiledclass WHERE NOT SqlSchemaName %STARTSWITH '%'");
                cmd.CommandTimeout = QueryTimeout;

                using (IDataReader reader = cmd.ExecuteReader()) {
                    while (reader.Read()) {
                        string dbName = (string)reader["SqlSchemaName"];
                        result.Add(new CacheDatabaseInfo(DatabaseServices, dbName));
                    }
                }
            }

            return result;
        }

        /// <summary>
        /// Returns a list of table sources (e.g. tables, views) that belong to a given database. 
        /// The returned table sources must have different display names.
        /// </summary>
        /// <param name="database">Database from which we want to fetch the list of tables</param>
        /// <param name="isTableSourceToIgnore">The delegate to call to see if the table source should be ignored and excluded from the returned list</param>
        /// <returns>List of available table sources in the given database</returns>
        /// <exception cref="System.Data.Common.DbException">if an error occurs while accessing the database</exception>
        public override IEnumerable<ITableSourceInfo> ListTableSources(IDatabaseInfo database, IsTableSourceToIgnore isTableSourceToIgnore) {

            IList<ITableSourceInfo> tables = new List<ITableSourceInfo>();
            CacheDatabaseInfo databaseInfo = database as CacheDatabaseInfo;
            if (databaseInfo == null) {
                return null;
            }
            using (IDbConnection conn = DatabaseServices.TransactionService.CreateConnection()) {
                string sql = string.Format(@"SELECT SqlQualifiedNameQ, SqlTableName FROM %Dictionary.CompiledClass  
                                             WHERE SqlSchemaName = '{0}'
                                               AND ClassType IN ('persistent', 'view')", databaseInfo.Identifier);

                IDbCommand cmd = DatabaseServices.ExecutionService.CreateCommand(conn, sql);
                cmd.CommandTimeout = QueryTimeout;
                using (IDataReader reader = cmd.ExecuteReader()) {
                    while (reader.Read()) {
                        string tableName = (string)reader["SqlTableName"];
                        string qualifiedTableName = (string)reader["SqlQualifiedNameQ"];
                        if (!isTableSourceToIgnore(tableName)) {
                            tables.Add(new CacheTableSourceInfo(DatabaseServices, databaseInfo, tableName, qualifiedTableName));
                        }
                    }
                }
            }
            return tables;
        }

        private string GetQualifiedIdentifier(string schema, string tableName) {
            return DatabaseServices.DMLService.Identifiers.EscapeIdentifier(schema) + "." +
                   DatabaseServices.DMLService.Identifiers.EscapeIdentifier(tableName);
        }

        /// <summary>
        /// Returns the list of foreign keys of the table source (e.g. table, view)
        /// </summary>
        /// <param name="tableSource">Table source from which we want to fetch the list of foreign keys</param>        
        /// <returns>The list of foreign keys of the table</returns>
        /// <exception cref="System.Data.Common.DbException">if an error occurs while accessing the database</exception>
        public override IEnumerable<ITableSourceForeignKeyInfo> GetTableSourceForeignKeys(ITableSourceInfo tableSource) {
            var ts = tableSource as CacheTableSourceInfo;
            return (ts == null) ? null : GetForeignKeys(ts.ToEnumerable());
        }

        /// <summary>
        /// Returns the list of columns of the table source (e.g. table, view)
        /// </summary>
        /// <param name="tableSource">Table source from which we want to fetch the list of columns</param>        
        /// <returns>The columns of the table</returns>
        /// <exception cref="System.Data.Common.DbException">if an error occurs while accessing the database</exception>
        public override IEnumerable<ITableSourceColumnInfo> GetTableSourceColumns(ITableSourceInfo tableSource) {
            var ts = tableSource as CacheTableSourceInfo;
            /* TODO: Remove */
            System.Diagnostics.Trace.WriteLine(ts == null ? "ts == null" : "go ahead get columns");
            return (ts == null) ? null : GetColumns(ts.ToEnumerable(), GetDataTypeInfo, GetColumnInfo);
        }

        private static CacheTableSourceColumnInfo GetColumnInfo(ITableSourceInfo tableSource, string columnName, IDataTypeInfo dataType,
            bool isMandatory, bool isPrimaryKey, bool isAutoGenerated) {

            return new CacheTableSourceColumnInfo(tableSource, columnName, dataType, isMandatory, isPrimaryKey, isAutoGenerated);

        }

        private CacheDataTypeInfo GetDataTypeInfo(int intOdbcType, string cacheDataType, int length, int precision, int scale, int datetimePrecision) {
            /* TODO: Remove */
            System.Diagnostics.Trace.WriteLine("*******************GetDataTypeInfo: intOdbcType=" + intOdbcType);
            DBDataType dataType = DBDataType.UNKNOWN;
            int columnLength = 0;
            int columnDecimals = 0;
            CacheOdbcType odbcType = CacheOdbcType.UNKNOWN;

            if ((intOdbcType >= -7 && intOdbcType <= 12) || (intOdbcType == -11)) {
                odbcType = (CacheOdbcType)intOdbcType;
            }

            /* TODO: Remove */
            System.Diagnostics.Trace.WriteLine("*******************GetDataTypeInfo: odbcType=" + odbcType.ToString() + "; precision = " + precision);
            switch (odbcType) {
                case CacheOdbcType.GUID:
                    dataType = DBDataType.TEXT;
                    columnLength = length;
                    break;
                case CacheOdbcType.BIT:
                    if (precision > 1) {
                        dataType = DBDataType.LONGINTEGER;
                    } else {
                        dataType = DBDataType.BOOLEAN;
                        columnLength = 1;
                    }
                    break;
                case CacheOdbcType.TINYINT:
                    if (precision > 1) {
                        dataType = DBDataType.INTEGER;
                    } else {
                        dataType = DBDataType.BOOLEAN;
                        columnLength = 1;
                    }
                    break;
                case CacheOdbcType.BIGINT:
                    dataType = DBDataType.LONGINTEGER;
                    break;
                case CacheOdbcType.LONGVARBINARY:
                case CacheOdbcType.VARBINARY:
                case CacheOdbcType.BINARY:
                    dataType = DBDataType.BINARY_DATA;
                    break;
                case CacheOdbcType.NUMERIC:
                case CacheOdbcType.DECIMAL:
                    if (precision > 28 || scale > 8) {
                        dataType = DBDataType.TEXT;
                        columnLength = precision + 3;
                    } else if (scale == 0 && precision <= 9) {
                        dataType = DBDataType.INTEGER;
                    } else if (scale == 0 && precision >= 10 && precision <= 18) {
                        dataType = DBDataType.LONGINTEGER;
                    } else {
                        dataType = DBDataType.DECIMAL;
                        columnLength = precision;
                        columnDecimals = scale;
                    }
                    break;
                case CacheOdbcType.SMALLINT:
                case CacheOdbcType.INTEGER:
                    dataType = DBDataType.INTEGER;
                    break;
                case CacheOdbcType.FLOAT:
                    dataType = DBDataType.TEXT;
                    columnLength = precision > 23 ? 340 : 65; // 327 and 57 should be enough, but we will give more to be sure...
                    break;
                case CacheOdbcType.REAL:
                case CacheOdbcType.DOUBLE:
                    dataType = DBDataType.TEXT;
                    columnLength = 340; // 327 should be enough, but we will give +13 to be sure...
                    break;
                case CacheOdbcType.DATE:
                    dataType = DBDataType.DATE;
                    columnLength = 11; //YYYY-MM-DD
                    break;
                case CacheOdbcType.TIME:
                    dataType = DBDataType.TEXT;
                    columnLength = datetimePrecision == 0 ? 11 : datetimePrecision + 12; //[+-]hhh:mm:ss.nnnnnn + extra character for possible string ending
                    break;
                case CacheOdbcType.TIMESTAMP:
                    dataType = DBDataType.DATE_TIME;
                    columnLength = datetimePrecision == 0 ? 20 : datetimePrecision + 21; //YYYY-MM-DD hh:mm:ss.nnnnnn + extra character for possible string ending
                    break;
                case CacheOdbcType.CHAR:
                case CacheOdbcType.LONGVARCHAR:
                case CacheOdbcType.VARCHAR:
                    dataType = DBDataType.TEXT;
                    columnLength = Math.Min(int.MaxValue, length);
                    break;
                case CacheOdbcType.UNKNOWN:
                default:
                    dataType = DBDataType.UNKNOWN;
                    break;
            }

            return new CacheDataTypeInfo(dataType, cacheDataType, columnLength, columnDecimals);
        }

        private IEnumerable<ITableSourceColumnInfo> GetColumns(IEnumerable<CacheTableSourceInfo> tableSources) {
            return GetColumns(tableSources, GetDataTypeInfo, GetColumnInfo);
        }

        protected IEnumerable<ITableSourceColumnInfo> GetColumns(
            IEnumerable<CacheTableSourceInfo> tableSources, 
            CreateDataTypeInfo createDataTypeInfo,
            CreateColumnInfo createColumnInfo) {

            var columnsInfo = new List<ITableSourceColumnInfo>();

            using (IDbConnection conn = DatabaseServices.TransactionService.CreateConnection()) {

                string paramPrefix = DatabaseServices.ExecutionService.ParameterPrefix;
                string tableNames = "'" + tableSources.Select(t => t.Name).StrCat("','") + "'";

                string query = string.Format(@"SELECT 
                                              TABLE_NAME, COLUMN_NAME, odbctype, DATA_TYPE, 
                                              IS_NULLABLE, CHARACTER_MAXIMUM_LENGTH, NUMERIC_PRECISION, 
                                              NUMERIC_SCALE, PRIMARY_KEY, AUTO_INCREMENT , COLUMN_DEFAULT, DATETIME_PRECISION
                                              FROM INFORMATION_SCHEMA.COLUMNS 
                                              WHERE TABLE_SCHEMA= {0} 
                                                AND TABLE_NAME in (" + tableNames + @")
                                              ORDER BY ORDINAL_POSITION", paramPrefix + "schema");
                System.Diagnostics.Trace.WriteLine(query);

                IDbCommand cmd = DatabaseServices.ExecutionService.CreateCommand(conn, query);
                DatabaseServices.ExecutionService.CreateParameter(cmd, paramPrefix + "schema", DbType.String, tableSources.First().Database.Name);
                cmd.CommandTimeout = QueryTimeout;

                using (IDataReader reader = cmd.ExecuteReader()) {
                    while (reader.Read()) {

                        int length;
                        string tableName = (string)reader["TABLE_NAME"];
                        string columnName = (string)reader["COLUMN_NAME"];
                        int precision = reader["NUMERIC_PRECISION"] == DBNull.Value ? 0 : Convert.ToInt32(reader["NUMERIC_PRECISION"]);
                        int scale = reader["NUMERIC_SCALE"] == DBNull.Value ? 0 : Convert.ToInt32(reader["NUMERIC_SCALE"]);
                        int datetimePrecision = reader["DATETIME_PRECISION"] == DBNull.Value ? 0 : Convert.ToInt32(reader["DATETIME_PRECISION"]);
                        // Could not find what types are given in the DATA_TYPE column, 
                        // but could find a table which gives the integer value odbctype so using this.
                        int odbcType = reader["odbctype"] == DBNull.Value ? 0 : Convert.ToInt32(reader["odbctype"]);
                        string cacheDataType = (string)reader["DATA_TYPE"];

                        //longblobs and longtext might cause overflow so we need to protect the decoding
                        Int32.TryParse(Convert.ToString(reader["CHARACTER_MAXIMUM_LENGTH"]), out length);
                        if (length == 0) { length = int.MaxValue; }

                        IDataTypeInfo datatype = createDataTypeInfo(odbcType, cacheDataType, length, precision, scale, datetimePrecision);

                        bool isAutoGenerated = "YES".EqualsIgnoreCase((string)reader["AUTO_INCREMENT"]);
                        bool isPrimaryKey = "YES".EqualsIgnoreCase((string)reader["PRIMARY_KEY"]);
                        bool isMandatory = isAutoGenerated || "NO".EqualsIgnoreCase((string)reader["IS_NULLABLE"]);

                        ITableSourceInfo tableInfo = tableSources.First(t => t.Name.EqualsIgnoreCase(tableName));

                        ITableSourceColumnInfo columnInfo = createColumnInfo(tableInfo, columnName, datatype, isMandatory, isPrimaryKey, isAutoGenerated);
                        columnsInfo.Add(columnInfo);

                        // If the column is a reference to another table and there is no Foreign Key relationship on the column, then
                        // add it as a Foreign Key.
                        string columnQuery = string.Format(@"SELECT P.SqlFieldName, 
                                                                P.RuntimeType, P.Collection, P.Relationship AS RELATIONSHIP, P.Cardinality,  
                                                                P.Parent, P.SqlListDelimiter, P.SqlListType 
                                                             FROM %Dictionary.CompiledClass C, %Dictionary.CompiledProperty P 
                                                             WHERE P.parent = C.ID 
                                                               AND P.SqlFieldName  = {0}
                                                               AND NOT P.RuntimeType %STARTSWITH '%' 
                                                               AND C.SqlSchemaName = {1}
                                                               AND C.SqlTableName  = {2}", 
                            paramPrefix + "column", paramPrefix + "schema", paramPrefix + "table");
                        IDbCommand cmdColumn = DatabaseServices.ExecutionService.CreateCommand(conn, columnQuery);
                        DatabaseServices.ExecutionService.CreateParameter(cmdColumn, paramPrefix + "column", DbType.String, columnName);
                        DatabaseServices.ExecutionService.CreateParameter(cmdColumn, paramPrefix + "schema", DbType.String, tableSources.First().Database.Name);
                        DatabaseServices.ExecutionService.CreateParameter(cmdColumn, paramPrefix + "table", DbType.String, tableName);
                        cmd.CommandTimeout = QueryTimeout;
                        IDataReader readerColumn = cmdColumn.ExecuteReader();
                        if (readerColumn.Read()) {
                            // Check if it has a relationship defined, then this will be added as FK when we do the Foreign Keys, if no
                            // relationship defined then add it as a foreign key.
                            if ((bool)readerColumn["RELATIONSHIP"] == false) {
                                string foreignKeyName = columnName;
                                string referencedColumnName = (string)reader["REFERENCED_COLUMN_NAME"];
                                string referencedTableName = (string)reader["REFERENCED_TABLE_NAME"];
                                bool isCascadeDelete = "CASCADE".EqualsIgnoreCase((string)reader["DELETE_RULE"]);
                            }
                        }
                    }
                }
            }
            return columnsInfo;
        }

        protected IEnumerable<ITableSourceForeignKeyInfo> GetForeignKeys(IEnumerable<CacheTableSourceInfo> tableSources) {

            string paramPrefix = DatabaseServices.ExecutionService.ParameterPrefix;
            string tableNames = "";

            try {
                tableNames = "'" + tableSources.Select(t => t.Name).StrCat("','") + "'";
                IList<ITableSourceForeignKeyInfo> foreignKeys = new List<ITableSourceForeignKeyInfo>();
                //on mysql table_schema always equal to constraint_schema so we can shortcut to optimize
                string query = string.Format(@"SELECT t.TABLE_NAME, 
                                                      c.CONSTRAINT_NAME, c.COLUMN_NAME, c.REFERENCED_TABLE_NAME, c.REFERENCED_COLUMN_NAME, 
                                                      r.DELETE_RULE
                                               FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE c
                                                 INNER JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS t ON c.CONSTRAINT_NAME = t.CONSTRAINT_NAME 
                                                 INNER JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON r.CONSTRAINT_NAME = t.CONSTRAINT_NAME
                                               WHERE t.CONSTRAINT_TYPE = 'FOREIGN KEY' 
                                                 AND t.TABLE_SCHEMA = {0} 
                                                 AND c.CONSTRAINT_SCHEMA = {0} 
                                                 AND r.CONSTRAINT_SCHEMA = {0} 
                                                 AND t.TABLE_NAME  IN (" + tableNames + @")", paramPrefix + "schema");

                using (IDbConnection conn = DatabaseServices.TransactionService.CreateConnection()) {
                    IDbCommand cmd = DatabaseServices.ExecutionService.CreateCommand(conn, query);
                    //----------------- Caché --------------------
                    // Caché does not look at the parameter name, it assigns parameters in the order they appear, one per question mark "?"
                    // So the above query expects 3 parameters, although it is the same Caché expects 3, so add 3 parameters.
                    DatabaseServices.ExecutionService.CreateParameter(cmd, paramPrefix + "schema", DbType.String, tableSources.First().Database.Name);
                    cmd.CommandTimeout = QueryTimeout;
                    using (IDataReader reader = cmd.ExecuteReader()) {
                        while (reader.Read()) {
                            string tableName = (string)reader["TABLE_NAME"];
                            string foreignKeyName = (string)reader["CONSTRAINT_NAME"];
                            string columnName = (string)reader["COLUMN_NAME"];
                            string referencedColumnName = (string)reader["REFERENCED_COLUMN_NAME"];
                            string referencedTableName = (string)reader["REFERENCED_TABLE_NAME"];
                            bool isCascadeDelete = "CASCADE".EqualsIgnoreCase((string)reader["DELETE_RULE"]);

                            CacheTableSourceInfo tableSource = tableSources.First(t => t.Name.EqualsIgnoreCase(tableName));

                            string qualifiedReferencedTableName = GetQualifiedIdentifier(tableSource.Database.Name, referencedTableName);
                            ITableSourceInfo referencedTableSource = new CacheTableSourceInfo(DatabaseServices, tableSource.Database, referencedTableName, qualifiedReferencedTableName);
                            ITableSourceForeignKeyInfo foreignKeyInfo = new CacheTableSourceForeignKeyInfo(tableSource, foreignKeyName, columnName, referencedTableSource, referencedColumnName, isCascadeDelete);
                            foreignKeys.Add(foreignKeyInfo);
                        }
                    }
                    return foreignKeys;
                }
            }
            catch (Exception e) {
                OSTrace.Error(string.Format("Failed to retrieve foreign key information from database. Tables: {0}", tableNames), e);
                return new List<ITableSourceForeignKeyInfo>();
            }
        }

    }
}
