/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Data;
using System.Data.Common;
using System.Text;
using System.Linq;
using OutSystems.HubEdition.Extensibility.Data;
using OutSystems.HubEdition.Extensibility.Data.ExecutionService;
using InterSystems.Data.CacheTypes;
using InterSystems.Data.CacheClient;
using System.Text.RegularExpressions;
using OutSystems.HubEdition.Extensibility.Data.ConfigurationService;
using OutSystems.HubEdition.Extensibility.Data.TransactionService;
using OutSystems.RuntimeCommon;
using OutSystems.RuntimeCommon.Log;

namespace OutSystems.HubEdition.DatabaseProvider.Cache.Execution {

    /// <summary>
    ///Base implementation of a database service that handles the execution of statements made while connected to a database.
    /// </summary>
    public class CacheExecutionService : BaseExecutionService {

        /// <summary>
        /// Initializes a new instance of the <see cref="CacheExecutionService"/> class.
        /// </summary>
        /// <param name="databaseServices">The database services to be used with this execution service.</param>
        public CacheExecutionService(IDatabaseServices databaseServices) : base(databaseServices) { }

        /// <summary>
        /// Gets the prefix used to qualify command parameters (e.g. @)
        /// </summary>
        public override string ParameterPrefix {
            get {
                return "@"; 
            }
        }

        /// <summary>
        /// Checks if an exception was raised due to a connection error.
        /// </summary>
        /// <param name="e">Exception raised.</param>
        /// <returns>
        /// True if the exception was due to a connection problem, False otherwise.
        /// </returns>
        public override bool IsConnectionException(DbException e) {
            // There is not any way in Caché to determine whether it was a connection exception or not.
            // We can check the error code, error codes -10050 to -11002 in Caché indicates WinSock connection errors.
            // Other connection related errors:
            // -401: Fatal Connection error
            // -162: SQL Connection is not defined
            bool isConnError = false;
            if ( (e.ErrorCode >= -11002 && e.ErrorCode <= -10050) ||
                 (e.ErrorCode == -401) ||
                 (e.ErrorCode == -162) ) {
                isConnError = true;
            } 
            return isConnError;
        }

        protected override IDbCommand CreateCommand(IDbConnection connection) {
            return base.CreateCommand(connection);
        }


        public override void BulkInsert(DataTable tab) {
            using (var con = DatabaseServices.TransactionService.CreateConnection()) {

                string columns = "";
                string prepend = "";

                DbType[] dbTypes = new DbType[tab.Columns.Count];

                for (int i = 0; i < tab.Columns.Count; i++) {
                    columns += prepend + DatabaseServices.DMLService.Identifiers.EscapeIdentifier(tab.Columns[i].ColumnName);
                    prepend = ",";
                    dbTypes[i] = ConvertToDbType(tab.Columns[i].DataType);
                }

                StringBuilder sb = new StringBuilder();
                sb.Append("INSERT INTO ");
                sb.Append(tab.TableName);
                sb.Append("(");
                sb.Append(columns);
                sb.Append(") VALUES ");


                foreach (DataRow row in tab.Rows) {
                    sb.Append("('");
                    sb.Append(row.ItemArray.Select(p => ValueToLiteral(p)).StrCat("','"));
                    sb.Append("'),");
                }

                try {
                    using (IDbTransaction tran = con.BeginTransaction()) {
                        IDbCommand cmd = CreateCommand(con);
                        cmd.CommandText = sb.Remove(sb.Length - 1, 1).ToString();

                        cmd.ExecuteNonQuery();
                        tran.Commit();
                    }
                }
                catch (Exception) {
                    //downgrade to single log write and discard bad logs

                    foreach (DataRow row in tab.Rows) {
                        StringBuilder individualSB = new StringBuilder();
                        individualSB.Append("INSERT INTO ");
                        individualSB.Append(tab.TableName);
                        individualSB.Append("(");
                        individualSB.Append(columns);
                        individualSB.Append(") VALUES ");
                        individualSB.Append("('");
                        individualSB.Append(row.ItemArray.Select(p => ValueToLiteral(p)).StrCat("','"));
                        individualSB.Append("')");
                        try {
                            IDbCommand cmd = CreateCommand(con);
                            cmd.CommandText = individualSB.ToString();

                            cmd.ExecuteNonQuery();
                        }
                        catch (Exception ex) {
                            EventLogger.WriteError(ex.Message + Environment.NewLine + "Stack:" + Environment.NewLine + ex.StackTrace);
                        }
                    }
                }
            }
        }


        private string ValueToLiteral(object obj) {
            if (obj is DateTime) {
                return ((DateTime)obj).ToString("yyyy-MM-dd HH:mm:ss");
            } else if (obj is bool) {
                return ((bool)obj) ? "1" : "0";
            } else return DatabaseServices.DMLService.EscapeTextValue(obj.ToString());
        }

        /// <summary>
        /// Executes a command and returns the number of affected rows.
        /// This implementation does not use the <code>isApplication</code> flag, and logs exceptions.
        /// </summary>
        /// <param name="cmd">The command to execute.</param>
        /// <returns>The number of rows affected.</returns>
		public override int ExecuteNonQuery(IDbCommand cmd) {
            try {
                return cmd.ExecuteNonQuery();
            }
            catch (DbException e) {
                OSTrace.Error("Error executing ExecuteNonQuery (" + e.Message + ") with statement:" + Environment.NewLine + cmd.CommandText);
                throw;
            }
        }

        /// <summary>
        /// Executes a command(s) and returns the value of the first column of the first row in the resultset returned by the query.
        /// This implementation logs exceptions.
        /// </summary>
        /// <param name="cmd">The command to execute.</param>
        /// <returns>An object with the resulting first row and first column of the query defined in the query command.</returns>
        public override object ExecuteScalar(IDbCommand cmd) {
            object returnObject = null;

            try {
                // The Caché database cannot handle multiple SQL commands in one call.
                // Therefore have to parse the SQL statements, execute each and return only the last one's value.
                // We have to build a new cmd (IDbCommand) for each SQL statement, we also have to parse the parameters (IDataParameterColelction) 
                // to get the parameters (IDataParameter) of each SQL statement to add the correct parameters to the cmd.
                // Execute each with ExecuteNonQuery, we are not interested in the return, then for the last statement execute
                // the command with ExecuteScalar() and return this result.
                // If there is only one SQL statement this is east, simply call ExecuteScalar.

                string cmdText = cmd.CommandText;
                string pattern = @"(?<!@)@\w{1,}"; // Looks for parameter prefixed with @ and excludes anything starting with @@.
                Regex rgx = new Regex(pattern, RegexOptions.IgnoreCase);
                int numSqlStatements = 0;
                char[] delimiterChars = { ';' };
                string[] sqlStatements = cmdText.Split(delimiterChars);

                // Check if last statement is empty
                if (sqlStatements.Length > 0) {
                    string sqlLast = sqlStatements[sqlStatements.Length - 1].Trim();
                    numSqlStatements = sqlLast.Length == 0 ? sqlStatements.Length - 1 : sqlStatements.Length;
                }

                if (numSqlStatements > 1) {
                    for (int i = 0; i < numSqlStatements; i++) {
                        string sqlStatement = sqlStatements[i];
                        using (IDbCommand newCmd = CreateCommand(cmd.Connection, sqlStatement)) {

                            // Copy all the current command's parameters to the new command.
                            newCmd.CommandTimeout = cmd.CommandTimeout;
                            newCmd.CommandType = cmd.CommandType;
                            newCmd.Transaction = cmd.Transaction;
                            newCmd.UpdatedRowSource = cmd.UpdatedRowSource;

                            // Now parse and add Parameters
                            MatchCollection matchColl = rgx.Matches(sqlStatement);
                            foreach (Match m in matchColl) {
                                IDbDataParameter dataParam = (IDbDataParameter)cmd.Parameters[m.Value];
                                IDbDataParameter newParam = CreateParameter(newCmd, dataParam.ParameterName, dataParam.DbType, dataParam.Value);
                                SetParameterDirection(newParam, dataParam.Direction);
                            }

                            // Is this the last SQL statement?
                            if (i == (numSqlStatements - 1)) {
                                returnObject = newCmd.ExecuteScalar();
                            } else {
                                newCmd.ExecuteNonQuery();
                            }
                        }
                    }
                } else {
                    returnObject = cmd.ExecuteScalar();
                }

                return returnObject;
            }
            catch (DbException e) {
                OSTrace.Error("Error executing ExecuteScalar (" + e.Message + ") with statement:" + Environment.NewLine + cmd.CommandText);
                throw;
            }
        }


        /*
        /// <summary>
        /// Converts a type to its equivalent type in the target framework.
        /// </summary>
        /// <param name="type">The type to be converted.</param>
        /// <param name="providerType">The name of the type used by the provider.</param>
        /// <returns>A supported type by the database.</returns>
        /// <exception cref="System.NotSupportedException">When no suitable type is found.</exception>
        public override DbType ConvertToDbType(DBDataType type, string providerType) {

            if (DBDataType.TEXT == type) {

                //Remove extra info from name (ex: "NCHAR(10)")
                var providerTypeOnly = providerType.IsNullOrEmpty() ? "" : providerType.Split('(')[0];

                switch (providerTypeOnly.ToUpper()) {
                    case "VARCHAR":
                    case "CHAR":
                    case "CHARACTER":
                    case "CHAR VARYING":
                    case "CHARACTER VARYING":
                    case "LONGTEXT":
                    case "MEDIUMTEXT":
                    case "TINYTEXT":
                    case "TEXT":
                    case "ENUM":
                    case "SET":
                        return DbType.String;
                    case "BIGINT":
                        return DbType.Int64;
                    case "INTEGER":
                    case "INT":
                    case "MEDIUMINT":
                        return DbType.Int32;
                    case "FLOAT":
                    case "REAL":
                        return DbType.Single;
                    case "DOUBLE":
                        return DbType.Double;
                    case "DECIMAL":
                    case "NUMERIC":
                        return DbType.Decimal;
                    case "TIME":
                        return DbType.Time;
                    case "BINARY":
                    case "BINARY VARYING":
                        return DbType.Binary;
                    case "BIT":
                        return DbType.Boolean;
                    default:
                        return DbType.String;
                }
            }

            if (DBDataType.TIME == type) {
                throw new NotSupportedException("Unable to convert " + type.ToString() + " to DbType");
            }

            return base.ConvertToDbType(type, providerType);
        }
        */

        public override object TransformRuntimeToDatabaseValue(DbType dbType, object value) {

#if JAVA
            if ((dbType == Types.TIMESTAMP || dbType == Types.TIME) && value is String){
                if (string.IsNullOrEmpty((string)value)) {
                        value = "00:00:00";
                }
            }
#else
            if (dbType == DbType.Time && value is string) {

                if (string.IsNullOrEmpty((string)value)) {
                    value = "00:00:00";
                }
                TimeSpan result;
                if (TimeSpan.TryParse((string)value, out result)) {
                    return result;
                }
            }
#endif
            return base.TransformRuntimeToDatabaseValue(dbType, value);
        }

    }

}
