/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using OutSystems.HubEdition.Extensibility.Data.DMLService;
using OutSystems.RuntimeCommon;

namespace OutSystems.HubEdition.DatabaseProvider.Cache.DML {

    /// <summary>
    /// Class for generating the DML functions required by the applications to perform simple queries
    /// </summary>
    public class CacheDMLFunctions : BaseDMLFunctions {

        // The spelling of the entries in this enum should match exactly the DatePart of the DATEADD and DATEDIFF Caché functions.
        // It shall be used as string for the DatePart.
        private enum DateTimePart {
            Year,
            Quarter,
            Month,
            Week,
            WeekDay,
            Day,
            DayOfYear,
            Hour,
            Minute,
            Second,
            Millisecond
        }

        public string DefaultDateFormat {
            get { return "YYYY-MM-DD";  }
        }
        public string DefaultTimeFormat {
            get { return "HH24:MI:SS"; }
        }
        public string DefaultNullDate {
            get { return "1900-01-01";  }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CacheDMLFunctions"/> class.
        /// </summary>
        /// <param name="dmlService">The DML service.</param>
        internal CacheDMLFunctions(IDMLService dmlService) : base(dmlService) { }

        /// <summary>
        /// This property represents the associated DML service.
        /// </summary>
        public new CacheDMLService DMLService {
            get { return (CacheDMLService)base.DMLService; }
        }

        /// <summary>
        /// Returns a DML expression that computes the decimal number 'n' truncated to integer removing the decimal part of 'n'.
        /// </summary>
        /// <param name="n">DML expression of type Decimal that evaluates to the decimal number to truncate</param>
        /// <returns>
        /// A DML expression that evaluates to a Decimal.
        /// </returns>
        public override string Trunc(string n) {
            //return string.Format("TRUNCATE({0}, 0)", n);
            // Caché sates in SQL reference that TRUNCATE function exists, but when I used it got exception that it does
            // not exists, also in Caché management portal tried this and it states SQLUser.Truncate does not exist.
            return string.Format("ROUND({0}, 0, 1)", n);
        }

        /// <summary>
        /// Returns a DML expression that concatenates two strings: 't1' and 't2'.
        /// </summary>
        /// <param name="t1">A DML expression that evaluates to Text.</param>
        /// <param name="t2">A DML expression that evaluates to Text.</param>
        /// <returns>A DML expression that evaluates to Text.</returns>
        public override string Concat(string t1, string t2) {
            return string.Format("{0} || {1}", t1, t2);
        }

        /// <summary>
        /// Returns a DML expression that searches an expression for another expression and returns its starting position if found.
        /// Returns -1 if the <paramref name="search" /> expression is empty or cannot be found.
        /// </summary>
        /// <param name="t">A DML expression that evaluates to Text.</param>
        /// <param name="search">A DML expression that evaluates to Text.</param>
        /// <returns>
        /// A DML expression that evaluates to an Integer.
        /// </returns>
        public override string Index(string t, string search) {
            return string.Format("CAST((CHARINDEX({0}, {1}) - 1) AS INTEGER)", search, t);
        }

        /// <summary>
        /// Returns a DML expression that computes the number of characters in a string.
        /// </summary>
        /// <param name="t">A DML expression that evaluates to Text.</param>
        /// <returns>
        /// A DML expression that evaluates to an Integer.
        /// </returns>
        public override string Length(string t) {
            return string.Format("CHAR_LENGTH({0})", t);
        }

        /// <summary>
        /// Returns a DML expression that computes a substring beginning at <code>start</code> zero-based position
        /// and with <code>length</code> characters.
        /// </summary>
        /// <param name="t">A DML expression that evaluates to Text.</param>
        /// <param name="start">A DML expression that evaluates to an Integer, containing the start index.</param>
        /// <param name="length">A DML expression that evaluates to an Integer, containing the length of the text to return.</param>
        /// <returns>
        /// A DML expression that evaluates to Text.
        /// </returns>
        public override string Substr(string t, string start, string length) {
            return string.Format("SUBSTR({0}, {1} + 1, {2})", t, start, length);
        }

        /// <summary>
        /// Returns a DML expression that removes all leading and trailing white spaces from a string.
        /// </summary>
        /// <param name="t">A DML expression that evaluates to Text.</param>
        /// <returns>
        /// A DML expression that evaluates to Text.
        /// </returns>
        public override string Trim(string t) {
            return string.Format("TRIM({0})", t);
        }

        /// <summary>
        /// Returns a DML expression that adds days to a DateTime and returns a valid DataTime.
        /// </summary>
        /// <param name="dt">A DML expression that evaluates to a DateTime.</param>
        /// <param name="n">A DML expression that evaluates to a Integer.</param>
        /// <returns>
        /// A DML expression that evaluates to a DateTime.
        /// </returns>
        public override string AddDays(string dt, string n) {
            return DateAdd(DateTimePart.Day, dt, n);
        }

        /// <summary>
        /// Returns a DML expression that adds days to a DateTime and returns a valid DataTime.
        /// </summary>
        /// <param name="dt">A DML expression that evaluates to a DateTime.</param>
        /// <param name="n">A DML expression that evaluates to a Integer.</param>
        /// <returns>
        /// A DML expression that evaluates to a DateTime.
        /// </returns>
        public override string AddHours(string dt, string n) {
            return DateAdd(DateTimePart.Hour, dt, n);
        }

        /// <summary>
        /// Returns a DML expression that adds minutes to a DateTime and returns a valid DateTime.
        /// </summary>
        /// <param name="dt">A DML expression that evaluates to a DateTime.</param>
        /// <param name="n">A DML expression that evaluates to an Integer.</param>
        /// <returns>
        /// A DML expression that evaluates to a DateTime.
        /// </returns>
        public override string AddMinutes(string dt, string n) {
            return DateAdd(DateTimePart.Minute, dt, n);
        }

        /// <summary>
        /// Returns a DML expression that adds months to a DateTime and returns a valid DateTime.
        /// </summary>
        /// <param name="dt">A DML expression that evaluates to a DateTime.</param>
        /// <param name="n">A DML expression that evaluates to an Integer.</param>
        /// <returns>
        /// A DML expression that evaluates to a DateTime.
        /// </returns>
        public override string AddMonths(string dt, string n) {
            return DateAdd(DateTimePart.Month, dt, n);
        }

        /// <summary>
        /// Returns a DML expression that adds seconds to a DateTime and returns a valid DateTime.
        /// </summary>
        /// <param name="dt">A DML expression that evaluates to a DateTime.</param>
        /// <param name="n">A DML expression that evaluates to an Integer.</param>
        /// <returns>
        /// A DML expression that evaluates to a DateTime.
        /// </returns>
        public override string AddSeconds(string dt, string n) {
            return DateAdd(DateTimePart.Second, dt, n);
        }

        /// <summary>
        /// Returns a DML expression that adds years to a DateTime and returns a valid DateTime.
        /// </summary>
        /// <param name="dt">A DML expression that evaluates to a DateTime.</param>
        /// <param name="n">A DML expression that evaluates to an Integer.</param>
        /// <returns>
        /// A DML expression that evaluates to a DateTime.
        /// </returns>
        public override string AddYears(string dt, string n) {
            return DateAdd(DateTimePart.Year, dt, n);
        }

        /// <summary>
        /// Returns a DML expression that creates a new DateTime given a Date and a Time.
        /// </summary>
        /// <param name="d">A DML expression that evaluates to a Date.</param>
        /// <param name="t">A DML expression that evaluates to a Time.</param>
        /// <returns>
        /// A DML expression that evaluates to a DateTime.
        /// </returns>
        public override string BuildDateTime(string d, string t) {
            return string.Format("TO_TIMESTAMP(TO_CHAR({0}, 'YYYY-MM-DD') || ' ' || TO_CHAR({1}, 'HH24:MI:SS'), 'YYYY-MM-DD HH24:MI:SS')", d, t);
        }

        /// <summary>
        /// Returns a DML expression that computes the day of a DateTime.
        /// </summary>
        /// <param name="dt">A DML expression that evaluates to a DateTime.</param>
        /// <returns>
        /// A DML expression that evaluates to an Integer.
        /// </returns>
        public override string Day(string dt) {
            return string.Format("DAY({0})", dt);
        }

        /// <summary>
        /// Returns a DML expression that computes the week day of a DateTime, ranging from 0 (Sunday) to 6 (Saturday).
        /// </summary>
        /// <param name="dt">A DML expression that evaluates to a DateTime.</param>
        /// <returns>
        /// A DML expression that evaluates to an Integer.
        /// </returns>
        public override string DayOfWeek(string dt) {
            return string.Format("CAST(DATEPART(weekday, {0})-1 AS INTEGER)", dt);
        }

        /// <summary>
        /// Returns a DML expression that computes how many days have passed between two DateTimes.
        /// Returns zero if the two dates are the same, a positive integer if <paramref name="dt1" /> is smaller than <paramref name="dt2" />, and
        /// a negative number otherwise.
        /// </summary>
        /// <param name="dt1">First DML expression that evaluates to a DateTime.</param>
        /// <param name="dt2">Second DML expression that evaluates to a DateTime.</param>
        /// <returns>
        /// A DML expression that evaluates to an Integer.
        /// </returns>
        public override string DiffDays(string dt1, string dt2) {
            return DateDiff(DateTimePart.Day, dt1, dt2);
        }

        /// <summary>
        /// Returns a DML expression that computes how many hours have passed between two DateTimes.
        /// Returns zero if the two dates and hours are the same, a positive integer if <paramref name="dt1" /> is smaller than <paramref name="dt2" />, and
        /// a negative number otherwise.
        /// </summary>
        /// <param name="dt1">First DML expression that evaluates to a DateTime.</param>
        /// <param name="dt2">Second DML expression that evaluates to a DateTime.</param>
        /// <returns>
        /// A DML expression that evaluates to an Integer.
        /// </returns>
        public override string DiffHours(string dt1, string dt2) {
            return DateDiff(DateTimePart.Hour, dt1, dt2);
        }

        /// <summary>
        /// Returns a DML expression that computes how many minutes have passed between two DateTimes.
        /// Returns zero if the two dates, hours and minutes are the same, a positive integer if <paramref name="dt1" /> is smaller than <paramref name="dt2" />, and
        /// a negative number otherwise.
        /// </summary>
        /// <param name="dt1">A DML expression that evaluates to a DateTime.</param>
        /// <param name="dt2">A DML expression that evaluates to a DateTime.</param>
        /// <returns>
        /// A DML expression that evaluates to an Integer.
        /// </returns>
        public override string DiffMinutes(string dt1, string dt2) {
            return DateDiff(DateTimePart.Minute, dt1, dt2);
        }

        /// <summary>
        /// Returns a DML expression that computes how many seconds have passed between two DateTimes.
        /// Returns zero if the two dates, hours, minutes, and seconds are the same, a positive integer if <paramref name="dt1" /> is smaller than
        /// <paramref name="dt2" />, and a negative number otherwise.
        /// </summary>
        /// <param name="dt1">A DML expression that evaluates to a DateTime.</param>
        /// <param name="dt2">A DML expression that evaluates to a DateTime.</param>
        /// <returns>
        /// A DML expression that evaluates to an Integer.
        /// </returns>
        public override string DiffSeconds(string dt1, string dt2) {
            return DateDiff(DateTimePart.Second, dt1, dt2);
        }

        /// <summary>
        /// Returns a DML expression that computes the hour part of a DateTime.
        /// </summary>
        /// <param name="dt">A DML expression that evaluates to a DateTime.</param>
        /// <returns>
        /// A DML expression that evaluates to an Integer.
        /// </returns>
        public override string Hour(string dt) {
            return string.Format("DATEPART(hour, {0})", dt);
        }

        /// <summary>
        /// Returns a DML expression that computes the minute part of a DateTime.
        /// </summary>
        /// <param name="dt">A DML expression that evaluates to a DateTime.</param>
        /// <returns>
        /// A DML expression that evaluates to an Integer.
        /// </returns>
        public override string Minute(string dt) {
            return string.Format("DATEPART(minute, {0})", dt);
        }

        /// <summary>
        /// Returns a DML expression that computes the month part of a DateTime.
        /// </summary>
        /// <param name="dt">A DML expression that evaluates to a DateTime.</param>
        /// <returns>
        /// A DML expression that evaluates to an Integer.
        /// </returns>
        public override string Month(string dt) {
            return string.Format("DATEPART(month, {0})", dt);
        }

        /// <summary>
        /// Returns a DML expression that computes a new date from a year, month, and day.
        /// </summary>
        /// <param name="y">A DML expression that evaluates to an Integer.</param>
        /// <param name="m">A DML expression that evaluates to an Integer.</param>
        /// <param name="d">A DML expression that evaluates to an Integer.</param>
        /// <returns>
        /// A DML expression that evaluates to a Date.
        /// </returns>
        //----------------------------- Caché -----------------------//
        // Assuming the date is in format of:
        // yyyy-mm-dd 
        // For example: "2016-02-23"
        public override string NewDate(string y, string mo, string d) {
            return CreateDateTime(y, mo, d, "0", "0", "0");
        }

        /// <summary>
        /// Returns a DML expression that computes a new DateTime from a year, month, day, hour, minute, and second.
        /// </summary>
        /// <param name="y">A DML expression that evaluates to an Integer.</param>
        /// <param name="mo">A DML expression that evaluates to an Integer.</param>
        /// <param name="d">A DML expression that evaluates to an Integer.</param>
        /// <param name="h">A DML expression that evaluates to an Integer.</param>
        /// <param name="m">A DML expression that evaluates to an Integer.</param>
        /// <param name="s">A DML expression that evaluates to an Integer.</param>
        /// <returns>
        /// A DML expression that evaluates to DateTime.
        /// </returns>
        //----------------------------- Caché -----------------------//
        // Assuming the date and time is in format of:
        // yyyy-mm-dd hh:mm:ss
        // For example: "2016-02-23" and "12:37:45"
        public override string NewDateTime(string y, string mo, string d, string h, string m, string s) {
            return CreateDateTime(y, mo, d, h, m, s);
        }

        /// <summary>
        /// Returns a DML expression that computes a new Time from an hour, minute, and second.
        /// </summary>
        /// <param name="h">A DML expression that evaluates to an Integer.</param>
        /// <param name="m">A DML expression that evaluates to an Integer.</param>
        /// <param name="s">A DML expression that evaluates to an Integer.</param>
        /// <returns>
        /// A DML expression that evaluates to Time.
        /// </returns>
        public override string NewTime(string h, string m, string s) {
            return NewDateTime("1900", "1", "1", h, m, s);
        }

        private string CreateDateTime(string y, string mo, string d, string h, string m, string s) {
            return string.Format("TO_TIMESTAMP({0} || '-' || {1} || '-' || {2} ||' ' || {3} ||':' || {4} ||':' || {5}, '{6} {7}')", 
                y, mo, d, h, m, s, DefaultDateFormat, DefaultTimeFormat);
        }

        /// <summary>
        /// Returns a DML expression that computes the seconds part of a DateTime.
        /// </summary>
        /// <param name="dt">A DML expression that evaluates to a DateTime.</param>
        /// <returns>
        /// A DML expression that evaluates to an Integer.
        /// </returns>
        public override string Second(string dt) {
            return string.Format("DATEPART(second, {0})", dt);
        }

        /// <summary>
        /// Returns a DML expression that computes the year part of a DateTime.
        /// </summary>
        /// <param name="dt">A DML expression that evaluates to a DateTime.</param>
        /// <returns>
        /// A DML expression that evaluates to an Integer.
        /// </returns>
        public override string Year(string dt) {
            return string.Format("DATEPART(year, {0})", dt);
        }

        /// <summary>
        /// Returns a DML expression that converts a Boolean expression to an Integer. The expression evaluates into
        /// 1 if the boolean is True, or 0 if False.
        /// </summary>
        /// <param name="b">A DML expression that evaluates to a Boolean.</param>
        /// <returns>
        /// A DML expression that evaluates to an Integer.
        /// </returns>
        public override string BooleanToInteger(string b) {
            // In Caché Boolean is a Bit of 0 or 1 which is an Integer.
            return b;
        }

        /// <summary>
        /// Returns a DML expression that convers a Boolean in its textual representation: <code>True</code> or <code>False</code>.
        /// </summary>
        /// <param name="b">A DML expression that evaluates to Boolean.</param>
        /// <returns>
        /// A DML expression that evaluates to Text.
        /// </returns>
        public override string BooleanToText(string b) {
            return $"(CASE WHEN {b} = 0 THEN 'False' ELSE 'True' END)";
        }

        /// <summary>
        /// Returns a DML expression that converts a DateTime to a Date, by dropping the Time component.
        /// </summary>
        /// <param name="dt">A DML expression that evaluates to a DateTime.</param>
        /// <returns>
        /// A DML expression that evaluates to a Date.
        /// </returns>
        public override string DateTimeToDate(string dt) {
            return string.Format("CAST({0} AS DATE)", dt);
        }

        /// <summary>
        /// Returns a DML expression that converts a DateTime to its textual representation, using a specified format.
        /// Elise van der Riet: This also should have had the comment:
        /// So I have to assume that this function should have had a comment stating: Format only the Date part and add NULL time formatted HH24:MM:SS.
        /// If you run this function's unit test and they pass over format of "DD/MM/YYYY", then format the date part only, then add
        /// a NULL time. But what if they send format of "DD/MM/YYYY HH24:MM:SS"? How do you know that you should not replace the time?
        /// So the solution would be cast the entire thinf to a TimeStamp with the given format, lets hope this always works.
        /// </summary>
        /// <param name="dt">A DML expression that evaluates to a DateTime.</param>
        /// <param name="dateFormat">Date format used to serialize the date component of the text value (e.g. YYYY-MM-DD).</param>
        /// <returns>
        /// A DML expression that evaluates to Text.
        /// </returns>
        public override string DateTimeToText(string dt, string dateFormat) {
            return $"TO_CHAR({dt}, '{TranslateDateFormatToCache(dateFormat) + " " + TranslateTimeFormatToCache(dateFormat)}')";
        }

        /// <summary>
        /// Returns a DML expression that converts a DateTime to a Time, by dropping the Date component.
        /// </summary>
        /// <param name="dt">A DML expression that evaluates to a DateTime.</param>
        /// <returns>
        /// A DML expression that evaluates to a Time.
        /// </returns>
        public override string DateTimeToTime(string dt) {
            return $"TO_TIMESTAMP('{DefaultNullDate} ' || TO_CHAR({dt}, '{DefaultTimeFormat}'), '{DefaultDateFormat} {DefaultTimeFormat}')";
        }

        /// <summary>
        /// Returns a DML expression that converts a Date to its textual representation, using a specified format.
        /// </summary>
        /// <param name="d">A DML expression that evaluates to a Date.</param>
        /// <param name="dateFormat">Date format used to serialize the date component of the text value (e.g. YYYY-MM-DD).</param>
        /// <returns>
        /// A DML expression that evaluates to Text.
        /// </returns>
        public override string DateToText(string dt, string dateFormat) {
            return string.Format("TO_CHAR({0}, '{1}')", dt, TranslateDateFormatToCache(dateFormat));
        }

        /// <summary>
        /// Returns an SQL expression that converts a Decimal to a Boolean. A Decimal value of 0.0 is False, all other values are True.
        /// </summary>
        /// <param name="d">A DML expression that evaluates to a Decimal.</param>
        /// <returns>
        /// A DML expression that evaluates to Boolean.
        /// </returns>
        public override string DecimalToBoolean(string d) {
            return $"CASE {d} WHEN 0 THEN 0 ELSE 1 END";
        }

        /// <summary>
        /// Returns a DML expression that converts a Decimal to an Integer.
        /// </summary>
        /// <param name="d">A DML expression that evaluates to a Decimal.</param>
        /// <returns>
        /// A DML expression that evaluates to a Boolean.
        /// </returns>
        public override string DecimalToInteger(string d) {
            return string.Format("CAST({0} AS INTEGER)", d);
        }

        /// <summary>
        /// Returns a DML expression that converts a Decimal to its textual representation.
        /// </summary>
        /// <param name="d">A DML expression that evaluates to a Decimal.</param>
        /// <returns>
        /// A DML expression that evaluates to a Decimal.
        /// </returns>
        public override string DecimalToText(string d) {
            return string.Format("CAST({0} AS CHAR VARYING)", d);
        }

        /// <summary>
        /// Returns a DML expression that converts an Integer to a Boolean.
        /// A Decimal value of 0 is False, all other values are True.
        /// </summary>
        /// <param name="i">A DML expression that evaluates to an Integer.</param>
        /// <returns>
        /// A DML expression that evaluates to a Boolean.
        /// </returns>
        public override string IntegerToBoolean(string i) {
            return $"CASE {i} WHEN 0 THEN 0 ELSE 1 END";
        }

        /// <summary>
        /// Returns a DML expression that converts an Integer to a Decimal.
        /// </summary>
        /// <param name="i">A DML expression that evaluates to an Integer.</param>
        /// <returns>
        /// A DML expression that evaluates to a decimal.
        /// </returns>
        public override string IntegerToDecimal(string i) {
            return string.Format("CAST({0} AS DECIMAL({1},{2}))", i, Constants.DecimalTotalPrecision, Constants.DecimalDecimals);
        }

        /// <summary>
        /// Returns a DML expression that converts an Integer to its textual representation.
        /// </summary>
        /// <param name="i">A DML expression that evaluates to an Integer.</param>
        /// <returns>
        /// A DML expression that evaluates to Text.
        /// </returns>
        public override string IntegerToText(string i) {
            return string.Format("CAST({0} AS CHAR VARYING)", i);
        }

        /// <summary>
        /// Returns a DML expression that computes a Null Date (1900-01-01).
        /// </summary>
        /// <returns>
        /// A DML expression that evaluates to a Date.
        /// </returns>
        public override string NullDate() {
            return NewDate("1900", "1", "1");
        }

        /// <summary>
        /// Returns a DML expression that converts Text to a Date.
        /// </summary>
        /// <param name="t">A DML expression that evaluates to Text.</param>
        /// <param name="dateFormat">Date format used to serialize the date component of the text value (e.g. YYYY-MM-DD).</param>
        /// <returns>
        /// A DML expression that evaluates to a Date.
        /// </returns>
        public override string TextToDate(string dt, string dateFormat) {
            return string.Format("TO_DATE({0}, '{1}')", dt, TranslateDateFormatToCache(dateFormat));
        }

        /// <summary>
        /// Provides a DML expression that converts Text 't' to a DateTime value.
        /// </summary>
        /// <param name="t">DML expression that evaluates to a text value</param>
        /// <param name="dateFormat">date format used to serialize the date component of the text value (e.g. YYYY-MM-DD)</param>
        /// <returns>
        /// DML expression of type DateTime
        /// </returns>
        public override string TextToDateTime(string dt, string dateFormat) {
            return string.Format("TO_TIMESTAMP({0}, '{1}')", dt, TranslateDateFormatToCache(dateFormat) + " " + TranslateTimeFormatToCache(dateFormat));
        }

        /// <summary>
        /// Returns a DML expression that converts Text to a DateTime.
        /// </summary>
        /// <param name="t">A DML expression that evaluates to Text.</param>
        /// <returns>
        /// A DML expression that evaluates to a DateTime.
        /// </returns>
        public override string TextToDecimal(string t) {
            return string.Format("CAST({0} AS DECIMAL({1},{2}))", t, Constants.DecimalTotalPrecision, Constants.DecimalDecimals);
        }

        /// <summary>
        /// Returns a DML expression that converts Text to an Integer.
        /// </summary>
        /// <param name="t">A DML expression that evaluates to Text.</param>
        /// <returns>
        /// A DML expression that evaluates to an Integer.
        /// </returns>
        public override string TextToInteger(string t) {
            return string.Format("CAST({0} AS INTEGER)", t);
        }

        /// <summary>
        /// Returns a DML expression that converts Text to Time.
        /// </summary>
        /// <param name="t">A DML expression that evaluates to Text.</param>
        /// <returns>
        /// A DML expression that evaluates to Time.
        /// </returns>
        public override string TextToTime(string t) {
            // First had this as:
            // But then got this exception:
            // System.InvalidCastException : Object must implement IConvertible. - Error converting the result: [System.DateTime]00:00:00
            // Thus now assuming that it msut have the Date part present, cannot really send only the TIME.
            // Also when the t time string is received here for some reason has single quotes around it. 
            // This is so in the tests, will this be the case always from OutSystems?
            // We also do not know what the date value in t is, so strip the date of t out and
            // add default null date of 1900-01-01
            return $"TO_TIMESTAMP('{DefaultNullDate} ' || TO_CHAR(CAST({t} AS TIMESTAMP), 'HH24:MI:SS'), 'YYYY-DD-MM HH24:MI:SS')";
        }

        /// <summary>
        /// Returns a DML expression that converts a Time to its text value in the format <code>hh:mm:ss</code>.
        /// </summary>
        /// <param name="t">A DML expression that evaluates to Time.</param>
        /// <returns>
        /// A DML expression that evaluates to Text.
        /// </returns>
        /*
        The Unit Test TestTimeToText failed because it sends date made from 1900-01-01 00:00:00, and expected "00:00:00" 
        to be returned and received back "12:00:00".
        The reason is that our implementation for TimeToText adhered to the description for this function which states 
        the time is to be converted to its text value in the format "hh:mm:ss". This (lower case h) format is according 
        to the OutSystems format for a 12-hour format, the 24 hour format is capital H or HH. We therefore interpreted 
        this that it must be the 12 hour format so midnight (00:00:00) will be returned as 12:00:00 and not 00:00:00.
        Either the test should be adapted or the description of TimeToText should be changed, it should then return the 24 hour format?
        */
        public override string TimeToText(string t) {
            return string.Format("TO_CHAR({0}, '{1}')", t, TranslateTimeFormatToCache("HH:mm:ss"));
        }

        /// <summary>
        /// Returns a DML expression that converts a Decimal to a Long Integer.
        /// </summary>
        /// <param name="d">A DML expression that evaluates to a Decimal.</param>
        /// <returns>A DML expression that evaluates to Long Integer.</returns>
        public override string DecimalToLongInteger(string d) {
            return string.Format("CAST({0} AS BIGINT)", d);
        }

        /// <summary>
        /// Returns a DML expression that converts an Integer to an (untyped) Identifier.
        /// </summary>
        /// <param name="i">A DML expression that evaluates to an Integer.</param>
        /// <returns>A DML expression that evaluates to an Integer.</returns>
        public override string IdentifierToInteger(string id) {
            return string.Format("IFNULL({0}, 0, CAST({1} AS INTEGER))", id, id);
        }

        /// <summary>
        /// Provides a DML expression that converts Identifier 'id' to a Long Integer value.
        /// </summary>
        /// <param name="id">DML expression that evaluates to a Long Integer value</param>
        /// <returns>DML expression of type Long Integer</returns>
        public override string IdentifierToLongInteger(string id) {
            return string.Format("IFNULL({0}, 0, CAST({1} AS BIGINT))", id, id);
        }

        /// <summary>
        /// Returns a DML expression that converts an Identifier to its textual representation.
        /// </summary>
        /// <param name="id">A DML expression that evaluates to Text.</param>
        /// <returns>A DML expression that evaluates to Text.</returns>
        public override string IdentifierToText(string id) {
            return string.Format("IFNULL({0}, '', {0})", id);
        }

        /// <summary>
        /// Returns a DML expression that converts a Long Integer to an Integer.
        /// </summary>
        /// <param name="b">A DML expression that evaluates to a Long Integer.</param>
        /// <returns>A DML expression that evaluates to Integer.</returns>
        public override string LongIntegerToInteger(string b) {
            return string.Format("CAST({0} AS INTEGER)", b);
        }

        /// <summary>
        /// Returns a DML expression that converts a Long Integer to a Decimal.
        /// </summary>
        /// <param name="b">A DML expression that evaluates to a Long Integer.</param>
        /// <returns>A DML expression that evaluates to Decimal.</returns>
        public override string LongIntegerToDecimal(string b) {
            return string.Format("CAST({0} AS DECIMAL(37,8))", b);
        }

        /// <summary>
        /// Returns a DML expression that converts an Integer to a Long Integer.
        /// </summary>
        /// <param name="b">A DML expression that evaluates to an Integer.</param>
        /// <returns>A DML expression that evaluates to Long Integer.</returns>
        public override string IntegerToLongInteger(string b) {
            return string.Format("CAST({0} AS BIGINT)", b);
        }

        /// <summary>
        /// Returns a DML expression that converts a Long Integer to its textual representation.
        /// </summary>
        /// <param name="b">A DML expression that evaluates to a Long Integer.</param>
        /// <returns>A DML expression that evaluates to Text.</returns>
        public override string LongIntegerToText(string b) {
            return string.Format("CAST({0} AS CHAR VARYING)", b);
        }

        /// <summary>
        /// Returns a DML expression that converts Text to a Long Integer.
        /// </summary>
        /// <param name="t">A DML expression that evaluates to Text.</param>
        /// <returns>A DML expression that evaluates to a Long Integer.</returns>
        public override string TextToLongInteger(string t) {
            return string.Format("CAST({0} AS BIGINT)", t);
        }

        #region Date-handling
        /*
         * OutSystems Date formats:
         *   Day:
         *   - d: day without leading zero;
         *   - dd: day WITH leading zero;
         *   - ddd: abbreviated day name;
         *   - dddd: full day name;
         *   Month:
         *   - M: month without leading zero;
         *   - MM: month WITH leading zero;
         *   - MMM: abbreviated month name;
         *   - MMMM: full month name;
         *   Year:
         *   - y: last one or two digits of the year;
         *   - yy: last two digits of the year;
         *   - yyyy: year;
         *   Hour:
         *   - h: hour from 0 to 12 without leading zero;
         *   - hh: hour from 0 to 12 WITH leading zero;
         *   - H: hour from 0 to 24 without leading zero;
         *   - HH: hour from 0 to 24 WITH leading zero;
         *   Minute:
         *   - m: minutes without leading zero;
         *   - mm: minutes WITH leading zero;
         *   Second:
         *   - s: seconds without leading zero;
         *   - ss: seconds WITH leading zero;
         *   AM Designator:
         *   - t: first letter of AM or PM;
         *   - tt: AM or PM.
         *   
         *   Caché date formats:
         *   D: Day of week (1-7). By default, 1 is Sunday (the first day of the week), but this designation is configurable; refer to the DAYOFWEEK function.
         *   DD: Two-digit day of month (01-31).
         *   DY: Abbreviated name of the day, as specified by the WeekdayAbbr property of the current locale. The defaults are:  Sun Mon Tue Wed Thu Fri Sat
         *   DAY: Name of day, as specified by the WeekdayName property in the current locale. The defaults are:  Sunday Monday Tuesday Wednesday Thursday Friday Saturday
         *   MM: Two-digit month number (01-12; 01 = JAN).
         *   MON: Abbreviated name of month, as specified by the MonthAbbr property in the current locale. The defaults are:  Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec. Not case-sensitive.
         *   MONTH: Full name of the month, as specified by the MonthName property in the current locale. The defaults are:  January February March April May June July August September October November December. Not case-sensitive.
         *   YYYY: Four-digit year.
         *   YYY: Last 3 digits of the year.
         *   YY: Last 2 digits of the year.
         *   Y: Last digit of the year.
         *   RRRR: Four-digit year.
         *   RR: Last 2 digits of the year.
         *   DDD: Day of the Year (see below).
         *   J: Julian date (number of days since January 1, 4712 BC (BCE)).
         *   HH: Hour of Day (1 through 12)
         *   HH12: Hour of Day (1 through 12)
         *   HH24: Hour of Day (0 through 23)
         *   MI: Minute (0 through 59)
         *   SS: Second (0 through 59)
         *   SSSSS: Seconds since midnight (0 through 86388)
         *   AM / PM: Meridian Indicator (AM = before noon, PM = after noon). Converts a time value to 12hour format with the appropriate AM or PM suffix. The returned AM or PM suffix is derived from the time value, not from which format code you specified. In the format you can use either AM or PM; they are functionally identical.
         *   
         */

        private string TranslateDateFormatToCache(string dateFormat) {

            string dateFormatCopy = String.Copy(dateFormat);

            // Split the time off
            int positionOfH = dateFormat.IndexOf('H');
            positionOfH = positionOfH >= 0 ? positionOfH : dateFormat.IndexOf('h');

            if (positionOfH == 0) { // Position of H cannot be 0, if it is then this format string starts with time and it has no date
                dateFormatCopy = string.Empty;
            } else {
                if (positionOfH > 0) {
                    dateFormatCopy = dateFormatCopy.Substring(0, positionOfH + 1);
                    dateFormatCopy.Trim();
                }
            }

            /*
            *  Day:
            *  -d: day without leading zero; -> This has no equivalent in cache, have to convert to DD (Two-digit day of month (01-31))
            *  -dd: day WITH leading zero;   -> DD
            *  -ddd: abbreviated day name;   -> DY
            *  -dddd: full day name;         -> DAY
            */

            if (dateFormatCopy.Length > 0) {
                if (dateFormatCopy.IndexOf("dddd") >= 0) {
                    // Replace dddd with DAY
                    dateFormatCopy = dateFormatCopy.Replace("dddd", "DAY");
                } else if (dateFormatCopy.IndexOf("ddd") >= 0) {
                    // Replace ddd with DY
                    dateFormatCopy = dateFormatCopy.Replace("ddd", "DY");
                } else if (dateFormatCopy.IndexOf("dd") >= 0) {
                    // Replace dd with DD
                    dateFormatCopy = dateFormatCopy.Replace("dd", "DD");
                } else if (dateFormatCopy.IndexOf("d") >= 0) {
                    // Replace d with DD - there is no equivalent for d in Caché
                    dateFormatCopy = dateFormatCopy.Replace("d", "DD");
                }

                /*
                *  Month:
                *  -M: month without leading zero; -> MM: No equivalent for this in Caché use MM: Two-digit month number (01-12)
                *  -MM: month WITH leading zero;   -> MM
                *  -MMM: abbreviated month name;   -> MON
                *  -MMMM: full month name;         -> MONTH
                */

                if (dateFormatCopy.IndexOf("MMMM") >= 0) {
                    // Replace MMMM with MONTH
                    dateFormatCopy = dateFormatCopy.Replace("MMMM", "MONTH");
                } else if (dateFormatCopy.IndexOf("MMM") >= 0) {
                    // Replace MMM with MON
                    dateFormatCopy = dateFormatCopy.Replace("MMM", "MON");
                } else if (dateFormatCopy.IndexOf("MM") >= 0) {
                    // Nothing to replace
                } else if (dateFormatCopy.IndexOf("M") >= 0) {
                    // Replace M with MM because there is no equivalent for M in Caché
                    dateFormatCopy = dateFormatCopy.Replace("M", "MM");
                }

                /*
                 *  Year:
                 *  - y: last one or two digits of the year; -> Y
                 *  - yy: last two digits of the year; -> YY
                 *  - yyyy: year; -> YYYY
                 */

                // Replace y with Y
                dateFormatCopy = dateFormatCopy.Replace("y", "Y");

            } else {
                dateFormatCopy = DefaultDateFormat;
            }

            return dateFormatCopy;

        }

        private string TranslateTimeFormatToCache(string dateFormat) {

            string timeFormatCopy = String.Copy(dateFormat);

            // Split the date off
            int positionOfH = dateFormat.IndexOf('H');
            positionOfH = positionOfH >= 0 ? positionOfH : dateFormat.IndexOf('h');

            if (positionOfH >= 0) {
                timeFormatCopy = timeFormatCopy.Substring(positionOfH);
                timeFormatCopy.Trim();

                /*
                *  Hour:
                *  -h: hour from 0 to 12 without leading zero; -> No equivalent in Caché, use HH
                *  -hh: hour from 0 to 12 WITH leading zero;   -> HH
                *  -H: hour from 0 to 24 without leading zero; -> No equivalent in Caché, use HH24
                *  -HH: hour from 0 to 24 WITH leading zero;   -> HH24
                */
                if (timeFormatCopy.IndexOf("HH") >= 0) {
                    // Replace MMMM with MONTH
                    timeFormatCopy = timeFormatCopy.Replace("HH", "HH24");
                } else if (timeFormatCopy.IndexOf("hh") >= 0) {
                    // Replace MMMM with MONTH
                    timeFormatCopy = timeFormatCopy.Replace("hh", "HH");
                } else if (timeFormatCopy.IndexOf("H") >= 0) {
                    // Replace MMMM with MONTH
                    timeFormatCopy = timeFormatCopy.Replace("H", "HH24");
                } else if (timeFormatCopy.IndexOf("h") >= 0) {
                    // Replace MMMM with MONTH
                    timeFormatCopy = timeFormatCopy.Replace("h", "HH");
                }

                /*
                *  Minute:
                *  -m: minutes without leading zero; -> No equivalent in Caché, use MI
                *  -mm: minutes WITH leading zero;   -> MI
                */
                if (timeFormatCopy.IndexOf("mm") >= 0) {
                    // Replace m with MI
                    timeFormatCopy = timeFormatCopy.Replace("mm", "MI");
                } else if (timeFormatCopy.IndexOf("m") >= 0) {
                    // Replace m with MI
                    timeFormatCopy = timeFormatCopy.Replace("m", "MI");
                }

                /*
                *  Second:
                *  -s: seconds without leading zero; -> No equivalent in Caché, use SS
                *  -ss: seconds WITH leading zero;   -> SS
                */
                if (timeFormatCopy.IndexOf("ss") >= 0) {
                    // Replace m with MI
                    timeFormatCopy = timeFormatCopy.Replace("ss", "SS");
                } else if (timeFormatCopy.IndexOf("s") >= 0) {
                    // Replace m with MI
                    timeFormatCopy = timeFormatCopy.Replace("s", "SS");
                }

                /*
                *  AM Designator:
                *  -t: first letter of AM or PM;
                *  -tt: AM or PM.
                */

                // In Caché if either AM or PM is added then the date conversion will establish whether it is AM or PM
                // according to the time supplied and will automatically determine whether AM or PM should be dsiplayed,
                // so we convert either t or tt to AM.
                if (timeFormatCopy.IndexOf("tt") >= 0) {
                    timeFormatCopy = timeFormatCopy.Replace("tt", "AM");
                } else if (timeFormatCopy.IndexOf("t") >= 0) {
                    timeFormatCopy = timeFormatCopy.Replace("t", "AM");
                }
            } else {
                timeFormatCopy = DefaultTimeFormat;
            }

            return timeFormatCopy;

        }

        private static string DateAdd(DateTimePart part, string dt, string n) {
            return string.Format("DATEADD({0}, {1}, {2})", part.ToString().ToLower(), n, dt);
        }

        private static string DateDiff(DateTimePart part, string dt1, string dt2) {
            return string.Format("DATEDIFF({0}, {1}, {2})", part.ToString().ToLower(), dt1, dt2);
        }

        #endregion

    }
}
